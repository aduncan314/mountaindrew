Django==2.2.2
mistune==0.8.4
psycopg2==2.8.3
Pygments==2.4.2
pytz==2019.1
sqlparse==0.3.0


<b>note: I'll update the code so it's formatted better at some point, but I want to post quickly</b>

To all of my loyal reader,

You may have noticed that an <em>edited</em> date and time was showing up even for some blog posts that happened at the same time (I only noticed it 20 minutes ago). I was confused because I thought I had already accounted for this.

Well, I had, but actually, no, I hadn't. I defined a method in the model that defines a blog post.

<code style=display:block;white-space:pre-wrap>
class BlogPost(models.Model):
    is_published = models.BooleanField()
    date_created = models.DateTimeField()
    last_updated = models.DateTimeField()
    date_published = models.DateTimeField(null=True, blank=True)

    # ... stuff that doesn't matter here...

    def is_edited(self):
        time_diff = self.last_updated - self.date_published
        # Seconds are not cumulative
        return (time_diff.seconds > 2 * 60) or (time_diff.days > 0)
</code>

I spent a little time on this because I was initially confused by the fact that the <code>seconds</code> attribute is not cumulative. If I update a page exactly one day later, the attribute will be zero. When I noticed the problem I was further confused by the fact that posts that I immediately published instead of saving and publishing later didn't have this issue. If I publish and save in one go, it's done a little differently than if I save and publish later. Usually when I publish later I use a button that can be customized by inheriting from the built in Django <code>admin.ModelAdmin</code>.

Until about 6:15 today this was the code (skipping a few distracting lines):
<code style=display:block;white-space:pre-wrap>
class BlogPostAdmin(admin.ModelAdmin):
    list_display = ['title', 'is_published', 'date_created', 'date_published']
    ordering = ['date_created']
    actions = ['publish']

    def publish(self, request, queryset):
        blogs_published = queryset.update(is_published=True, last_updated=timezone.now(), date_published=timezone.now())
        msg = "1 blog published" if blogs_published == 1 else f"{blogs_published} blogs published"
        self.message_user(request, msg)
</code>

I'm not sure what drove me to call <code>timezone.now()</code> twice, but that turned out to be the problem. Of course this wouldn't happen if the difference in time could be negative.